---
# Deploy EdgePaaS app (blue-green) dynamically with Docker
- name: Deployment Notice!!!
  ansible.builtin.debug:
    msg: >
      EdgePaaS uses self-managed blue/green deployment.
      Active color is derived from persisted state.
      Do not pass color vars manually.

#------------------------------
# Detect CICD OR Local
#------------------------------
- name: Detect if running in CI/CD
  ansible.builtin.set_fact:
    is_cicd: "{{ lookup('env','GITHUB_ACTIONS') | default(false) | bool }}"

- name: Who Is host?
  command: hostname
  register: result

- name: Show Hostname
  ansible.builtin.debug:
    msg: "Hostname: {{ result.stdout_lines }}"

- name: Debug CI/CD detection
  ansible.builtin.debug:
    msg: "Running in CI/CD? {{ is_cicd }}"

- name: Set ansible_host Explicitly
  set_fact:
    ansible_host: "{{ lookup('env', 'EC2_IP') }}"
  when: is_cicd

- name: Debug ansible_host
  ansible.builtin.debug:
    msg: "Connecting to Ansible_host: {{ ansible_host }}"

- name: Set health check host
  ansible.builtin.set_fact:
    health_host: "127.0.0.1"

# ---------------------------------------
# Capture supplied ports (environment)
# ---------------------------------------
- name: Capture supplied host ports from environment
  ansible.builtin.set_fact:
    supplied_active_port: "{{ lookup('env', 'ACTIVE_HOST_PORT') | default('0') }}"
    supplied_inactive_port: "{{ lookup('env', 'INACTIVE_HOST_PORT') | default('0') }}"

# ---------------------------------------
# Resolve final ports (bootstrap defaults if 0 or empty)
# ---------------------------------------
- name: Resolve final ports
  ansible.builtin.set_fact:
    resolved_active_port: "{{ (supplied_active_port | int) if (supplied_active_port | int) > 0 else 8080 }}"
    resolved_inactive_port: "{{ (supplied_inactive_port | int) if (supplied_inactive_port | int) > 0 else 8081 }}"

# ---------------------------------------
# Inform if default ports are used
# ---------------------------------------
- name: Inform if default ports are used
  ansible.builtin.debug:
    msg: "Complete host ports NOT supplied, using defaults: ACTIVE={{ resolved_active_port }}, INACTIVE={{ resolved_inactive_port }}"
  when: supplied_active_port | int == 0 or supplied_inactive_port | int == 0

# ---------------------------------------
# Validate resolved host ports
# ---------------------------------------
- name: Validate resolved host ports
  ansible.builtin.assert:
    that:
      - (resolved_active_port | int) != (resolved_inactive_port | int)
      - (resolved_active_port | int) > 0
      - (resolved_inactive_port | int) > 0
      - (resolved_active_port | int) < 65536
      - (resolved_inactive_port | int) < 65536
    fail_msg: >
      Invalid host port configuration.
      ACTIVE={{ resolved_active_port }},
      INACTIVE={{ resolved_inactive_port }}

- name: Show final host ports to be used
  ansible.builtin.debug:
    msg:
      - "Stable ACTIVE host port   → {{ resolved_active_port }}"
      - "Stable INACTIVE host port → {{ resolved_inactive_port }}"

# --------------------------------------------------
# Docker filesystem setup
# --------------------------------------------------
- name: Create directories for app
  ansible.builtin.file:
    path: /opt/edgepaas/app
    state: directory
    owner: deploy
    group: deploy
    mode: '0755'

- name: Copy docker disk setup script
  ansible.builtin.copy:
    src: files/setup_docker_disk.sh
    dest: /usr/local/bin/setup_docker_disk.sh
    owner: root
    group: root
    mode: '0755'
  become: true

- name: Run docker disk setup script
  ansible.builtin.command: /usr/local/bin/setup_docker_disk.sh
  become: true
  register: docker_disk_result
  changed_when: "'already configured' not in docker_disk_result.stdout"

- name: Ensure docker mount exists
  ansible.builtin.wait_for:
    path: /var/lib/docker
    state: present
    timeout: 60

- name: Restart docker
  ansible.builtin.service:
    name: docker
    state: restarted
  become: true

# --------------------------------------------------
# Pull images
# --------------------------------------------------
- name: Pull Docker images
  ansible.builtin.docker_image:
    name: "{{ DOCKER_USER }}/{{ APP_NAME }}:latest-{{ item }}"
    source: pull
  loop:
    - blue
    - green

# --------------------------------------------------
# Load persisted active color
# --------------------------------------------------
- name: Load active color if exists
  ansible.builtin.slurp:
    src: /opt/edgepaas/ACTIVE_COLOR
  register: active_color_file
  ignore_errors: true

- name: Bootstrap active_color on first deployment
  ansible.builtin.set_fact:
    active_color: blue
  when: active_color_file is failed

- name: Set active_color from persisted state
  ansible.builtin.set_fact:
    active_color: "{{ active_color_file.content | b64decode }}"
  when: active_color_file is succeeded

- name: Derive inactive color
  ansible.builtin.set_fact:
    inactive_color: "{{ 'green' if active_color == 'blue' else 'blue' }}"

# --------------------------------------------------
# Derive current nginx ports (state-only)
# --------------------------------------------------
- name: Derive nginx ports from active color
  ansible.builtin.set_fact:
    nginx_active_port: "{{ resolved_active_port if active_color == 'blue' else resolved_inactive_port }}"
    nginx_inactive_port: "{{ resolved_inactive_port if active_color == 'blue' else resolved_active_port }}"

- name: Show current host ports before Swap
  ansible.builtin.debug:
    msg:
      - "Current ACTIVE   → {{ active_color }} on {{ nginx_active_port }}"
      - "Current INACTIVE → {{ inactive_color }} on {{ nginx_inactive_port }}"

  # Determine if any container is using the inactive port and klll
- name: Check for inactive container port
  ansible.builtin.shell: >
    docker ps -a --filter "name={{ APP_NAME }}-{{ inactive_color }}" --format "{{ '{{.Names}}' }}"
  register: container_on_inactive
  ignore_errors: true

- name: Log inactive container status
  ansible.builtin.debug:
    msg: >-
      {% if container_on_inactive.stdout != "" %}
        [EDGEPAAS_WARNING] Container {{ container_on_inactive.stdout }} is running on inactive color {{ inactive_color }} (port {{ nginx_inactive_port }}) and will be stopped.
      {% else %}
        No container running on inactive color {{ inactive_color }} (port {{ nginx_inactive_port }})
      {% endif %}

- name: Stop and remove inactive container if exists
  ansible.builtin.shell: >
    docker rm -f {{ container_on_inactive.stdout }}
  when: container_on_inactive.stdout != ""
  ignore_errors: true

# -------------------------------
# Recheck if the inactive container was removed
# -------------------------------
- name: Recheck inactive container removal
  ansible.builtin.shell: >
    docker ps -a --filter "name={{ APP_NAME }}-{{ inactive_color }}" --format "{{ '{{.Names}}' }}"
  register: container_check_after_removal
  ignore_errors: true

- name: Fail if inactive container still exists
  ansible.builtin.fail:
    msg: >-
      [EDGEPAAS_CRITICAL] Container {{ container_check_after_removal.stdout }}
      still exists on inactive color {{ inactive_color }} (port {{ nginx_inactive_port }}).
      Deployment cannot continue. Manual intervention required!
  when: container_check_after_removal.stdout != ""

- name: Log inactive container successfully removed
  ansible.builtin.debug:
    msg: "[EDGEPAAS_OK] Inactive container successfully removed. Port {{ nginx_inactive_port }} is free for deployment."
  when: container_check_after_removal.stdout == ""


# --------------------------------------------------
# Deploy new version to inactive slot
# --------------------------------------------------
- name: Start new container on inactive slot
  ansible.builtin.docker_container:
    name: "{{ APP_NAME }}-{{ inactive_color }}"
    image: "{{ DOCKER_USER }}/{{ APP_NAME }}:latest-{{ inactive_color }}"
    state: started
    restart_policy: always
    ports:
      - "{{ nginx_inactive_port }}:{{ container_port | default(80) }}"
    env:
      DATABASE_URL: "{{ lookup('env','DATABASE_URL') }}"
      CONTAINER_PORT: "{{ container_port | default(80) | string }}"
      RUN_MIGRATIONS: "true"
    env_file: /opt/edgepaas/.env.test

- name: Determine source of DATABASE_URL
  ansible.builtin.set_fact:
    database_url_source: >-
      {% if lookup('env','DATABASE_URL') | length > 0 %}
        environment variable
      {% else %}
        .env file (/opt/edgepaas/.env.test)
      {% endif %}

- name: Show which DATABASE_URL source is used
  ansible.builtin.debug:
    msg: "DATABASE_URL is taken from {{ database_url_source }}"

# --------------------------------------------------
# Healthcheck adjusted for GitHub Actions (minimal-like)
# --------------------------------------------------
- name: Wait for mapped inactive port to be open
  wait_for:
    host: "{{ health_host }}"
    port: "{{ nginx_inactive_port }}"
    timeout: 10
  ignore_errors: true

- name: HTTP check against mapped port
  uri:
    url: "http://{{ health_host }}:{{ nginx_inactive_port }}"
    method: GET
    status_code: 200
    timeout: 5
  register: health_check_port
  retries: 5
  delay: 3
  until: health_check_port.status == 200
  ignore_errors: true

- name: HTTP check /health endpoint
  uri:
    url: "http://{{ health_host }}:{{ nginx_inactive_port }}/health"
    method: GET
    status_code: 200
    timeout: 5
  register: health_check_endpoint
  retries: 5
  delay: 5
  until: health_check_endpoint.status == 200
  ignore_errors: true

- name: Show healthcheck results
  ansible.builtin.debug:
    msg:
      - "Port check status: {{ health_check_port.status }}"
      - "/health endpoint status: {{ health_check_endpoint.status }}"

- name: Send alert email if health check failed
  mail:
    host: smtp.example.com
    port: 587
    username: "{{ EMAIL_FROM }}"
    password: "{{ EMAIL_PASS }}"
    to: "{{ EMAIL_TO }}"
    subject: "❌ EdgePaaS Health Check Failure"
    body: |
      Pipeline Health check failed at {[ ansible_time }}!
      - Port status: {{ health_check_port.status }}
      - /health status: {{ health_check_endpoint.status }}
  when: health_check_port.status != 200 or health_check_endpoint.status != 200

- name: Fail if any health check failed
  fail:
    msg: |
      ❌ Health check failed! Details:
      - Port check status: {{ health_check_port.status }}
      - /health endpoint status: {{ health_check_endpoint.status }}
  when: health_check_port.status != 200 or health_check_endpoint.status != 200

# --------------------------------------------------
# Continue with swap, nginx, and cleanup (unchanged)
# --------------------------------------------------
- name: Define nginx swap intent
  ansible.builtin.set_fact:
    next_active_color: "{{ inactive_color }}"
    next_active_port: "{{ nginx_inactive_port }}"
    rollback_color: "{{ active_color }}"
    rollback_port: "{{ nginx_active_port }}"

- name: DEBUG nginx switch intent result
  ansible.builtin.debug:
    msg:
      - "Switching nginx to:"
      - "NEW ACTIVE → {{ next_active_color }} on {{ next_active_port }}"
      - "ROLLBACK   → {{ rollback_color }} on {{ rollback_port }}"

- name: Update nginx to new active container
  ansible.builtin.template:
    src: nginx.conf.j2
    dest: /etc/nginx/conf.d/edgepaas.conf
    owner: root
    group: root
    mode: '0644'
    force: true
  vars:
    active_port: "{{ next_active_port }}"
    inactive_port: "{{ rollback_port }}"
  become: true
  notify: Reload nginx

- name: Freeze swap state
  ansible.builtin.set_fact:
    new_active_color: "{{ next_active_color }}"
    new_active_port: "{{ next_active_port }}"
    old_active_color: "{{ rollback_color }}"
    old_active_port: "{{ rollback_port }}"

- name: Persist active color
  ansible.builtin.copy:
    content: "{{ new_active_color }}"
    dest: /opt/edgepaas/ACTIVE_COLOR

- name: Show final state
  ansible.builtin.debug:
    msg:
      - "ACTIVE   → {{ new_active_color }} on {{ new_active_port }}"
      - "OLD      → {{ old_active_color }} on {{ old_active_port }}"

- name: Test nginx config
  ansible.builtin.command: nginx -t
  become: true

- name: Ensure nginx is running
  ansible.builtin.service:
    name: nginx
    state: started
    enabled: true
  become: true

- name: Rollback window
  ansible.builtin.pause:
    minutes: 1

- name: Stop old container
  ansible.builtin.docker_container:
    name: "{{ APP_NAME }}-{{ old_active_color }}"
    state: absent
    force_kill: true
