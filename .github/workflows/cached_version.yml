name: EdgePaaS Pipeline with Full Caching (Terraform → Build → Deploy)

on:
  workflow_dispatch:
    inputs:
      tf_action:
        description: 'Terraform action (apply / destroy)'
        required: false
        default: 'apply'
      build_mode:
        description: 'Docker build mode (cache / no-cache)'
        required: false
        default: 'cache'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1

  # ---------- Terraform ----------
  TF_VERSION: 1.6.6
  TF_IN_AUTOMATION: true
  TF_DIR: ./iac
  TF_KEY: ${{ secrets.KEY }}
  TF_CIDR: ${{ secrets.MY_IP_CIDR }}
  TF_EMAILS: ${{ secrets.ALERT_EMAILS }}
  TF_AMOUNT: ${{ secrets.BUDGET_AMOUNT }}

  # ---------- App / Docker ----------
  DOCKER_USER: ${{ secrets.DOCKER_USER }}
  APP_NAME: edgeapp
  APP_TAG: ${{ secrets.APP_TAG }}

  # ---------- AWS ----------
  EDGEPAAS_AWS_ROLE: ${{ secrets.EDGEPAAS_AWS_ROLE }}

jobs:
# ============================================================
# TERRAFORM
# ============================================================
  terraform:
    name: Terraform Provisioning
    runs-on: ubuntu-latest
    outputs:
      tf_action: ${{ github.event.inputs.tf_action }}

    steps:
      - uses: actions/checkout@v4

      # Cache Terraform modules & plugins
      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: ${{ env.TF_DIR }}/.terraform
          key: terraform-modules-${{ hashFiles(env.TF_DIR + '/**/*.tf') }}
          restore-keys: terraform-modules-

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false -reconfigure

      - name: Terraform Format & Validate
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform fmt -recursive
          terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform plan -input=false \
            -var "alert_emails=${TF_EMAILS}" \
            -var "cidr_blocks=${TF_CIDR}" \
            -var "amount=${TF_AMOUNT}" \
            -var "key_name=${TF_KEY}"

      - name: Terraform Apply / Destroy
        working-directory: ${{ env.TF_DIR }}
        run: |
          if [[ "${{ github.event.inputs.tf_action }}" == "destroy" ]]; then
            terraform destroy -auto-approve -input=false \
              -var "alert_emails=${TF_EMAILS}" \
              -var "cidr_blocks=${TF_CIDR}" \
              -var "amount=${TF_AMOUNT}" \
              -var "key_name=${TF_KEY}"
          else
            terraform apply -auto-approve -input=false \
              -var "alert_emails=${TF_EMAILS}" \
              -var "cidr_blocks=${TF_CIDR}" \
              -var "amount=${TF_AMOUNT}" \
              -var "key_name=${TF_KEY}"
          fi

# ============================================================
# BUILD
# ============================================================
  build:
    name: Build & Push Docker Images
    needs: terraform
    if: needs.terraform.outputs.tf_action != 'destroy'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Set BUILD_VERSION
        run: echo "BUILD_VERSION=${GITHUB_SHA}" >> $GITHUB_ENV

      # -----------------------------
      # Cache Docker layers
      # -----------------------------
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.docker-cache
          key: docker-layer-cache-${{ github.sha }}
          restore-keys: docker-layer-cache-

      # -----------------------------
      # Cache Python dependencies
      # -----------------------------
      - name: Cache Python pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: pip-cache-${{ hashFiles('docker/app/requirements.txt') }}
          restore-keys: pip-cache-

      - name: Build & Push Docker (cache / no-cache)
        run: |
          DOCKER_FLAGS=""
          if [[ "${{ github.event.inputs.build_mode }}" == "no-cache" ]]; then
            DOCKER_FLAGS="--no-cache"
          fi

          docker build $DOCKER_FLAGS -t ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-blue ./docker
          docker build $DOCKER_FLAGS -t ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-green ./docker

          docker push ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-blue
          docker push ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-green

# ============================================================
# DEPLOY
# ============================================================
  deploy:
    name: Deploy via Ansible
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Prepare email variables
        run: |
          emails=${TF_EMAILS//[\[\]\"]}
          IFS=',' read -r EMAIL_FROM EMAIL_TO <<< "$emails"
          echo "EMAIL_FROM=$EMAIL_FROM" >> $GITHUB_ENV
          echo "EMAIL_TO=$EMAIL_TO" >> $GITHUB_ENV

      - name: Fetch EC2 public IP dynamically
        run: |
          EC2_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${APP_TAG}" \
            --query "Reservations[].Instances[] | [?State.Name=='running'].PublicIpAddress | [0]" \
            --output text)
          if [[ -z "$EC2_IP" || "$EC2_IP" == "null" ]]; then
            echo "❌ Could not determine EC2 IP"
            exit 1
          fi
          echo "EC2_IP=$EC2_IP" >> $GITHUB_ENV

      - name: Install Ansible
        run: sudo apt update && sudo apt install -y ansible

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Create inventory
        run: |
          cat > test_dir/inventory.ini <<EOF
          [Edge]
          edgepaas ansible_host=${EC2_IP} ansible_user=ec2-user ansible_python_interpreter=/usr/bin/python3 ansible_ssh_args='-o StrictHostKeyChecking=no'
          EOF
          cat test_dir/inventory.ini

      - name: Run Ansible
        working-directory: test_dir
        run: ansible-playbook -i inventory.ini run.yml \
          --extra-vars "DOCKER_USER=${DOCKER_USER} APP_NAME=${APP_NAME} EC2_IP=${EC2_IP}"
        env:
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
          RUN_MIGRATIONS: ${{ secrets.RUN_MIGRATIONS }}
          BOTH_DB: "true"
          EMAIL_FROM: ${{ env.EMAIL_FROM }}
          EMAIL_TO: ${{ env.EMAIL_TO }}
          EMAIL_PASS: ${{ secrets.ALERT_EMAIL_PASSWORD }}
          ANSIBLE_HOST_KEY_CHECKING: "false"

      - name: Final confirmation
        run: echo "✅ EdgePaaS pipeline completed successfully"

# ============================================================
# FINAL REPORT
# ============================================================
  final_report:
    name: Final Pipeline Email Report
    needs: [terraform, build, deploy]
    runs-on: ubuntu-latest

    steps:
      - name: Build pipeline status summary
        run: |
          STATUS="SUCCESS"
          if [[ "${{ needs.terraform.result }}" != "success" ]] || \
             [[ "${{ needs.build.result }}" != "success" ]] || \
             [[ "${{ needs.deploy.result }}" != "success" ]]; then
            STATUS="FAILED"
          fi

          SUMMARY="Pipeline Status: $STATUS\n\n"
          SUMMARY+="Terraform: ${{ needs.terraform.result }}\n"
          SUMMARY+="Build: ${{ needs.build.result }}\n"
          SUMMARY+="Deploy: ${{ needs.deploy.result }}\n"

          echo "PIPELINE_STATUS=$STATUS" >> $GITHUB_ENV
          echo -e "$SUMMARY" > summary.txt

      - name: Send pipeline email
        run: echo -e "$(cat summary.txt)" | mailx -s "EdgePaaS Pipeline: $PIPELINE_STATUS" -r "$EMAIL_FROM" "$EMAIL_TO"
        env:
          EMAIL_FROM: ${{ env.EMAIL_FROM }}
          EMAIL_TO: ${{ env.EMAIL_TO }}
