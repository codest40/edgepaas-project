name: Cached EdgePaaS Pipeline (Terraform → Build → Deploy)

on:
# push: {}
  workflow_dispatch:
    inputs:
      tf_action:
        description: 'Terraform action (apply / destroy)'
        required: false
        default: 'apply'
      build_mode:
        description: 'Docker build mode (cache / no-cache)'
        required: false
        default: 'cache'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1

  # ---------- Terraform ----------
  TF_VERSION: 1.6.6
  TF_DIR: ./iac
  TF_KEY: ${{ secrets.KEY }}
  TF_CIDR: ${{ secrets.MY_IP_CIDR }}
  TF_EMAILS: ${{ secrets.ALERT_EMAILS }}
  TF_AMOUNT: ${{ secrets.BUDGET_AMOUNT }}

  # ---------- App / Docker ----------
  DOCKER_USER: ${{ secrets.DOCKER_USER }}
  APP_NAME: edgeapp
  APP_TAG: ${{ secrets.APP_TAG }}

  # ---------- AWS ----------
  EDGEPAAS_AWS_ROLE: ${{ secrets.EDGEPAAS_AWS_ROLE }}

jobs:
# ============================================================
# TERRAFORM
# ============================================================
  terraform:
    name: Terraform Provisioning
    runs-on: ubuntu-latest
    outputs:
      tf_action: ${{ github.event.inputs.tf_action }}

    steps:
      - uses: actions/checkout@v4

      # Cache Terraform modules & provider plugins
      - name: Cache Terraform
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.TF_DIR }}/.terraform
            ${{ env.TF_DIR }}/.terraform.lock.hcl
          key: terraform-modules-${{ hashFiles('iac/**/*.tf') }}
          restore-keys: terraform-modules-

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false -reconfigure

      - name: Terraform Format & Validate
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform fmt -recursive
          terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform plan -input=false \
            -var "alert_emails=${TF_EMAILS}" \
            -var "cidr_blocks=${TF_CIDR}" \
            -var "amount=${TF_AMOUNT}" \
            -var "key_name=${TF_KEY}"

      - name: Terraform Apply / Destroy
        working-directory: ${{ env.TF_DIR }}
        run: |
          if [[ "${{ github.event.inputs.tf_action }}" == "destroy" ]]; then
            terraform destroy -auto-approve -input=false \
              -var "alert_emails=${TF_EMAILS}" \
              -var "cidr_blocks=${TF_CIDR}" \
              -var "amount=${TF_AMOUNT}" \
              -var "key_name=${TF_KEY}"
          else
            terraform apply -auto-approve -input=false \
              -var "alert_emails=${TF_EMAILS}" \
              -var "cidr_blocks=${TF_CIDR}" \
              -var "amount=${TF_AMOUNT}" \
              -var "key_name=${TF_KEY}"
          fi

# ============================================================
# BUILD
# ============================================================
  build:
    name: Build & Push Docker Images
    needs: terraform
    if: needs.terraform.outputs.tf_action != 'destroy'
    runs-on: ubuntu-latest
    outputs:
      build_version: ${{ steps.set_build.outputs.build_version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set BUILD_VERSION
        id: set_build
        run: |
          if [[ "${{ github.event.inputs.build_mode }}" == "no-cache" ]]; then
            BUILD_VERSION=$(head /dev/urandom | tr -dc a-f0-9 | head -c6)
          else
            BUILD_VERSION="latest"
          fi

          echo "BUILD_VERSION=$BUILD_VERSION" >> $GITHUB_ENV
          echo "build_version=$BUILD_VERSION" >> $GITHUB_OUTPUT

      - name: Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      # -----------------------------
      # Cache Docker layers (registry)
      # -----------------------------
      - name: Build & Push Docker Images
        uses: docker/build-push-action@v4
        with:
          context: ./docker
          push: true
          tags: |
            ${{ secrets.DOCKER_USER }}/${{ env.APP_NAME }}:${{ steps.set_build.outputs.build_version }}-blue
            ${{ secrets.DOCKER_USER }}/${{ env.APP_NAME }}:${{ steps.set_build.outputs.build_version }}-green

          build-args: |
            BUILD_MODE=${{ github.event.inputs.build_mode }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_USER }}/${{ env.APP_NAME }}:cache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USER }}/${{ env.APP_NAME }}:cache,mode=max
          # Using --no-cache only if explicitly requested
          no-cache: ${{ github.event.inputs.build_mode == 'no-cache' }}

      # pip caching (layered in Dockerfile)
      - name: Cache Python pip
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: pip-cache-${{ hashFiles('docker/app/requirements.txt') }}
          restore-keys: pip-cache-

# ============================================================
# DEPLOY
# ============================================================
  deploy:
    name: Deploy via Ansible
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Prepare email variables
        run: |
          emails=${TF_EMAILS//[\[\]\"]}
          IFS=',' read -r EMAIL_FROM EMAIL_TO <<< "$emails"
          echo "EMAIL_FROM=$EMAIL_FROM" >> $GITHUB_ENV
          echo "EMAIL_TO=$EMAIL_TO" >> $GITHUB_ENV

      - name: Fetch EC2 public IP dynamically
        run: |
          EC2_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${APP_TAG}" \
            --query "Reservations[].Instances[] | [?State.Name=='running'].PublicIpAddress | [0]" \
            --output text)
          if [[ -z "$EC2_IP" || "$EC2_IP" == "null" ]]; then
            echo "❌ Could not determine EC2 IP"
            exit 1
          fi
          echo "EC2_IP=$EC2_IP" >> $GITHUB_ENV

      - name: Install Ansible
        run: sudo apt update && sudo apt install -y ansible

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Create inventory
        run: |
          cat > ansible/inventory.ini <<EOF
          [Edge]
          edgepaas ansible_host=${EC2_IP} ansible_user=ec2-user ansible_python_interpreter=/usr/bin/python3 ansible_ssh_args='-o StrictHostKeyChecking=no'
          EOF

          cat ansible/inventory.ini

      - name: Run Ansible
        working-directory: ansible
        run: |
          ansible-playbook -i inventory.ini run.yml --extra-vars "EC2_IP=${EC2_IP}"
        env:
          DOCKER_USER: ${{ env.DOCKER_USER }}
          APP_NAME: ${{ env.APP_NAME }}
          BUILD_VERSION: ${{ needs.build.outputs.build_version }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
          RUN_MIGRATIONS: ${{ secrets.RUN_MIGRATIONS }}
          USE_SQLITE: "false"
          BOTH_DB: "true"
          EMAIL_FROM: ${{ env.EMAIL_FROM }}
          EMAIL_TO: ${{ env.EMAIL_TO }}
          EMAIL_PASS: ${{ secrets.ALERT_EMAIL_PASSWORD }}
          ANSIBLE_HOST_KEY_CHECKING: "false"

      - name: Final confirmation
        run: echo "✅ EdgePaaS pipeline completed successfully"

# ============================================================
# FINAL REPORT
# ============================================================
  final_report:
    name: Final Pipeline Email Report
    needs: [terraform, build, deploy]
    runs-on: ubuntu-latest

    steps:
      - name: Prepare email variables
        run: |
          emails=${TF_EMAILS//[\[\]\"]}
          IFS=',' read -r EMAIL_FROM EMAIL_TO <<< "$emails"

          echo "EMAIL_FROM=$EMAIL_FROM" >> $GITHUB_ENV
          echo "EMAIL_TO=$EMAIL_TO" >> $GITHUB_ENV

      - name: Build pipeline status summary
        run: |
          STATUS="SUCCESS"
          if [[ "${{ needs.terraform.result }}" != "success" ]] || \
             [[ "${{ needs.build.result }}" != "success" ]] || \
             [[ "${{ needs.deploy.result }}" != "success" ]]; then
            STATUS="FAILED"
          fi

          echo "PIPELINE_STATUS=$STATUS" >> $GITHUB_ENV

          cat <<EOF > summary.txt
          Pipeline Status: $STATUS

          Terraform: ${{ needs.terraform.result }}
          Build: ${{ needs.build.result }}
          Deploy: ${{ needs.deploy.result }}
          EOF

      - name: Send Email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ env.EMAIL_FROM }}
          password: ${{ secrets.ALERT_EMAIL_PASSWORD }}
          subject: EdgePaaS Pipeline ${{ env.PIPELINE_STATUS }}
          body: file://summary.txt
          to: ${{ env.EMAIL_TO }}
          from: ${{ env.EMAIL_FROM }}
