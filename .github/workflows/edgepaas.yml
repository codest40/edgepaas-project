name: EdgePaaS Full Pipeline (Terraform → Build → Deploy)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      tf_action:
        description: 'Terraform action (apply / destroy)'
        required: false
        default: 'apply'

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1


  # ---------- Terraform ----------
  TF_VERSION: 1.6.6
  TF_IN_AUTOMATION: true
  TF_DIR: ./iac
  TF_KEY: ${{ secrets.KEY }}
  TF_CIDR: ${{ secrets.MY_IP_CIDR }}
  TF_EMAILS: ${{ secrets.ALERT_EMAILS }}
  TF_AMOUNT: ${{ secrets.BUDGET_AMOUNT }}

  # ---------- App / Docker ----------
  DOCKER_USER: ${{ secrets.DOCKER_USER }}
  APP_NAME: edgeapp
  APP_TAG: ${{ secrets.APP_TAG }}
  NO_CACHE: "true"

  # ---------- AWS ----------
  EDGEPAAS_AWS_ROLE: ${{ secrets.EDGEPAAS_AWS_ROLE }}

jobs:
# ============================================================
# TERRAFORM
# ============================================================
  terraform:
    name: Terraform Provisioning
    runs-on: ubuntu-latest

    outputs:
      tf_action: ${{ github.event.inputs.tf_action }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4


      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false -reconfigure

      - name: Terraform Format
        working-directory: ${{ env.TF_DIR }}
        run: terraform fmt -recursive

      - name: Terraform Validate
        working-directory: ${{ env.TF_DIR }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform plan -input=false \
            -var "alert_emails=${TF_EMAILS}" \
            -var "cidr_blocks=${TF_CIDR}" \
            -var "amount=${TF_AMOUNT}" \
            -var "key_name=${TF_KEY}"

      - name: Terraform Apply
        if: ${{ github.event.inputs.tf_action != 'destroy' }}
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform apply -auto-approve -input=false \
            -var "alert_emails=${TF_EMAILS}" \
            -var "cidr_blocks=${TF_CIDR}" \
            -var "amount=${TF_AMOUNT}" \
            -var "key_name=${TF_KEY}"

      - name: Terraform Destroy
        if: ${{ github.event.inputs.tf_action == 'destroy' }}
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform destroy -auto-approve -input=false \
            -var "alert_emails=${TF_EMAILS}" \
            -var "cidr_blocks=${TF_CIDR}" \
            -var "amount=${TF_AMOUNT}" \
            -var "key_name=${TF_KEY}"

# ============================================================
# BUILD
# ============================================================
  build:
    name: Build & Push Docker Images
    needs: terraform
    if: needs.terraform.outputs.tf_action != 'destroy'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker Login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASS }}

      - name: Set BUILD_VERSION
        run: echo "BUILD_VERSION=${GITHUB_SHA}" >> $GITHUB_ENV

      - name: Build & Push (no cache)
        if: env.NO_CACHE == 'true'
        run: |
          docker build --no-cache -t ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-blue ./docker
          docker build --no-cache -t ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-green ./docker

          docker push ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-blue
          docker push ${DOCKER_USER}/${APP_NAME}:${BUILD_VERSION}-green

# ============================================================
# DEPLOY
# ============================================================
  deploy:
    name: Deploy via Ansible
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ env.EDGEPAAS_AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Prepare email variables
        run: |
          emails=${TF_EMAILS//[\[\]\"]}
          IFS=',' read -r EMAIL_FROM EMAIL_TO <<< "$emails"

          echo "EMAIL_FROM=$EMAIL_FROM" >> $GITHUB_ENV
          echo "EMAIL_TO=$EMAIL_TO" >> $GITHUB_ENV

      - name: Fetch EC2 public IP dynamically
        run: |
          EC2_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${APP_TAG}" \
            --query "Reservations[].Instances[] | [?State.Name=='running'].PublicIpAddress | [0]" \
            --output text)

          if [[ -z "$EC2_IP" || "$EC2_IP" == "null" ]]; then
            echo "❌ Could not determine EC2 IP"
            exit 1
          fi

          echo "EC2_IP=$EC2_IP" >> $GITHUB_ENV
          echo "EC2 IP: $EC2_IP"

      - name: Install Ansible
        run: |
          sudo apt update
          sudo apt install -y ansible

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Create inventory
        run: |
          cat > test_dir/inventory.ini <<EOF
          [test]
          edgepaas ansible_host=${EC2_IP} ansible_user=ec2-user ansible_python_interpreter=/usr/bin/python3 ansible_ssh_args='-o StrictHostKeyChecking=no'
          EOF

          cat test_dir/inventory.ini

      - name: Run Ansible
        working-directory: test_dir
        run: |
          ansible-playbook -i inventory.ini run.yml \
            --extra-vars "DOCKER_USER=${DOCKER_USER} APP_NAME=${APP_NAME} EC2_IP=${EC2_IP}"
        env:
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
          RUN_MIGRATIONS: ${{ secrets.RUN_MIGRATIONS }}
          BOTH_DB: "true"
          EMAIL_FROM: ${{ env.EMAIL_FROM }}
          EMAIL_TO: ${{ env.EMAIL_TO }}
          EMAIL_PASS: ${{ secrets.ALERT_EMAIL_PASSWORD }}
          ANSIBLE_HOST_KEY_CHECKING: "false"

      - name: Final confirmation
        run: echo "✅ EdgePaaS pipeline completed successfully"

# --------------------------------------------------
# Prepare Repotr
# --------------------------------------------------
  final_report:
    name: Final Pipeline Email Report
    needs: [terraform, build, deploy]
    runs-on: ubuntu-latest
    steps:

      # --------------------------------------------------
      # Prepare summary
      # --------------------------------------------------
      - name: Build pipeline status summary
        run: |
          echo "Terraform: ${{ needs.terraform.result }}"
          echo "Build: ${{ needs.build.result }}"
          echo "Deploy: ${{ needs.deploy.result }}"

          STATUS="SUCCESS"
          if [[ "${{ needs.terraform.result }}" != "success" ]] || \
             [[ "${{ needs.build.result }}" != "success" ]] || \
             [[ "${{ needs.deploy.result }}" != "success" ]]; then
            STATUS="FAILED"
          fi

          SUMMARY="Pipeline Status: $STATUS\n\n"
          SUMMARY+="Terraform: ${{ needs.terraform.result }}\n"
          SUMMARY+="Build: ${{ needs.build.result }}\n"
          SUMMARY+="Deploy: ${{ needs.deploy.result }}\n"

          echo "PIPELINE_STATUS=$STATUS" >> $GITHUB_ENV
          echo -e "$SUMMARY" > summary.txt

      # --------------------------------------------------
      # Send email alert
      # --------------------------------------------------
      - name: Send pipeline email
        run: |
          echo -e "$(cat summary.txt)" | mailx -s "EdgePaaS Pipeline: $PIPELINE_STATUS" -r "$EMAIL_FROM" "$EMAIL_TO"
        env:
          EMAIL_FROM: ${{ env.EMAIL_FROM }}
          EMAIL_TO: ${{ env.EMAIL_TO }}
